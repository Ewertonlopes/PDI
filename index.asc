:source-highlighter: pygments
:toc: left
:stem:

= Atividades Práticas Processamento Digital de Imagens =
Ewerton Vasoncelos Lopes <ewerton.lopes.140@ufrn.edu.br>

O relatório a seguir diz respeito a todas atividades referentes às práticas desenvolvidas para a disciplina de Processamento Digital de Imagens - DCA0445 durante o período de 2023.2 na Universidade Federal do Rio Grande do Norte.

== Atividade 1: Manipulando Pixels

As primeiras atividades possuem um caráter introdutório para trabalhar o desenvolvimento da manipulação dos pixels de uma dada imagem qualquer. Para desenvolver essa competência se utilizou do desenvolvimento de um negativo de uma área de uma dada imagem de entrada e a reordenação de uma imagem em seus quadrantes.

=== Criando Negativo

O desenvolvimento de um negativo de uma área é feito de forma simples com uma entrada de uma imagem qualquer pelo argumento de linha de comando e uma entrada cin posterior de dois pontos.

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

int main(int argc, char** argv)
{
    cv::Mat image;
    cv::Vec3b val;
    
    cv::Point p1,p2;

    image = cv::imread(argv[1],cv::IMREAD_GRAYSCALE);
    
    do
    {
        std::cout<<"Ponto Inicial (x y):"; 
        std::cin>>p1.x>>p1.y;
    }while(p1.x > image.rows || p1.y > image.cols);

    do
    {
        std::cout<<"Ponto Final (x y):";
        std::cin>>p2.x>>p2.y;
    }while(p2.x > image.rows || p2.y > image.cols);

    int xin, xout, yin, yout;
    if(p1.x > p2.x){xin = p2.x; xout = p1.x;}
    else{xin = p1.x; xout = p2.x;} 

    if(p1.y > p2.y){yin = p2.y; yout = p1.y;}
    else {yin = p1.y; yout = p2.y;}

    for(int i = xin; i<=xout; i++)
    {
        for(int j = yin; j<yout; j++)
        {
            image.at<uchar>(i,j) = 255 - image.at<uchar>(i,j);
        }
    }

    cv::imshow("Negative", image);
    cv::waitKey();

    return 0;
}
----

A geração do negativo pode ser evidenciado pela parte do código logo abaixo onde se retira o valor da posição de cada pixel do valor de 255 no caso de usarmos um unsigned char para a geração da imagem.

[source,cpp]
----
for(int i = xin; i<=xout; i++)
{
    for(int j = yin; j<yout; j++)
    {
        image.at<uchar>(i,j) = 255 - image.at<uchar>(i,j);
    }
}
----

O resultado obtido pode ser visto na figura <<fig_neg>>.

[[fig_neg, Negativo]]
.Saída do programa negativo
image::images/negative.png[title="Execução do Programa em Negativo"]


=== Invertendo Quadrantes

O processo de inverter quadrantes segue uma lógica muito parecida com a que foi aplicada na atividade anterior. Apenas dessa vez devemos fazer isso de forma fixa a depender das dimensões da imagem. Porém, como forma de aprofundar os conhecimentos da biblioteca do openCV, se resolveu utilizar outros métodos internos a api sem o uso de loops externos e acessos aos pixels individuais. Como podemos ver no código logo abaixo a imagem foi repartida em quatro pedaços menores que a posteriori foram unidos nas posições corretas.

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

int main(int argc, char** argv)
{
    cv::Mat image;
    cv::Vec3b val;
    
    image = cv::imread(argv[1],cv::IMREAD_GRAYSCALE);
   
    cv::Mat sub11out = image(cv::Range(0,(image.rows/2) - 1), cv::Range(0,(image.cols/2) - 1));
  cv::Mat sub12out = image(cv::Range(0,(image.rows/2) - 1), cv::Range(image.cols/2,image.cols));
    cv::Mat sub21out = image(cv::Range(image.rows/2,image.rows), cv::Range(0,(image.cols/2)));
  cv::Mat sub22out = image(cv::Range(image.rows/2,image.rows), cv::Range(image.cols/2,image.cols));

    cv::Mat aux = image.clone();

    sub22out.copyTo(aux(cv::Rect(0,0,sub22out.cols, sub22out.rows)));
    sub12out.copyTo(aux(cv::Rect(0,image.cols/2,sub12out.cols, sub12out.rows)));
    sub21out.copyTo(aux(cv::Rect(image.rows/2,0,sub21out.cols, sub21out.rows)));
    sub11out.copyTo(aux(cv::Rect(image.rows/2,image.cols/2,sub11out.cols, sub11out.rows)));
    
    cv::imshow("Inverse", aux);
    cv::waitKey();

    return 0;
}
----

O resultado obtido pode ser visto na figura <<fig_quad>>.

[[fig_quad, Quadrants]]
.Saída do programa Quadrantes
image::images/quadrants.png[title="Saída do Programa Quadrantes."]


== Atividade 2: Salvando Imagens

A atividade seguinte foi desenvolvida para melhorar a compreensão do estudante quanto às formas de se guardar as imagens em um computador. Abaixo temos o código desenvolvido nesta atividade.

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>
#include <sstream>
#include <string>

int SIDE = 256;
int PERIODOS = 4;

int main(int argc, char** argv) 
{
  std::stringstream ss_img, ss_yml;
  cv::Mat image;

  ss_yml << "senoide-" << SIDE << ".yml";
  image = cv::Mat::zeros(SIDE, SIDE, CV_32FC1);

  cv::FileStorage fs(ss_yml.str(), cv::FileStorage::WRITE);

  for (int i = 0; i < SIDE; i++) {
    for (int j = 0; j < SIDE; j++) {
      image.at<float>(i, j) = 127 * sin(2 * M_PI * PERIODOS * j / SIDE) + 128;
    }
  }

  fs << "mat" << image;
  fs.release();

  cv::normalize(image, image, 0, 255, cv::NORM_MINMAX);
  image.convertTo(image, CV_8U);
  ss_img << "senoide-" << SIDE << ".png";
  cv::imwrite(ss_img.str(), image);

  fs.open(ss_yml.str(), cv::FileStorage::READ);
  fs["mat"] >> image;

  cv::normalize(image, image, 0, 255, cv::NORM_MINMAX);
  image.convertTo(image, CV_8U);

  cv::imshow("image", image);
  cv::waitKey();
}
----

Ao abrirmos os arquivos resultantes temos um arquivo que só pode ser compreendido por um visualizador de imagens gerado pelo png, como demonstra a figura <<fig_png>>, e um arquivo que pode ser facilmente compreendido por seres humanos no arquivo yml, sem contar as incontáveis possibilidades de que os dados podem ser salvos no formato yml, como demonstra a figura <<fig_yml>>.

[[fig_png, ImagensPng]]
.Saída do programa para a imagem PNG
image::images/imagempng.png[title="Dados no arquivo png."]

[[fig_yml, ImagensYML]]
.Saída do programa para o arquivo yml
image::images/imagemyml.png[title="Dados no arquivo yml."]

== Atividade 3: Dividindo Imagens

Incluindo codigo do exemplo <<exa_hello>>. 


Exemplo de equacao

stem:[\int_a^b f(x) dx]

